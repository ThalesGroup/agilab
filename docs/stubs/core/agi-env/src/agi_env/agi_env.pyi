"""AGILab environment bootstrapper and utility helpers.

The module exposes the :class:`AgiEnv` class which orchestrates project discovery,
virtual-environment management, packaging helpers, and convenience utilities used
by installers as well as runtime workers. Supporting free functions provide small
parsing and path utilities leveraged during setup.

Notes on singleton and pre‑init behavior
---------------------------------------
- ``AgiEnv`` behaves as a true singleton. Instance attributes are the source of
  truth; class attribute reads proxy to the singleton instance when initialised.
  Methods and descriptors are never shadowed by the delegation.
- A small subset of helpers is pre‑init safe and can be used before constructing
  an instance: :func:`AgiEnv.set_env_var`, :func:`AgiEnv.read_agilab_path`,
  :func:`AgiEnv._build_env`, and :func:`AgiEnv.log_info`. These functions avoid
  hard failures when the shared logger/environment has not been configured yet.
  Logging in that mode is best‑effort and may fall back to ``print``."""

import shlex
import ast
import asyncio
import getpass
import os
import re
import shutil
import psutil
import socket
import subprocess
import sys
import traceback
from functools import lru_cache
from pathlib import Path, PureWindowsPath, PurePosixPath
import tempfile
from dotenv import dotenv_values, set_key
import tomlkit
import logging
import astor
from pathspec import PathSpec
from pathspec.patterns import GitWildMatchPattern
import py7zr
import urllib.request
import inspect
import ctypes
from ctypes import wintypes
import importlib.util
import importlib.resources as importlib_resources
from concurrent.futures import ThreadPoolExecutor
from threading import RLock
from agi_env.agi_logger import AgiLogger
import inspect as _inspect
from typing import Any

def _resolve_worker_hook(*args: Any, **kwargs: Any) -> Any: ...

def _select_hook(*args: Any, **kwargs: Any) -> Any: ...

LEVEL_RES = [
    # Optional leading time like "11:20:03 " or "11:20:03,123 "
    re.compile(r'^\s*(?:\d{2}:\d{2}:\d{2}(?:[.,]\d+)?\s+)?(DEBUG|INFO|WARNING|ERROR|CRITICAL)\b', re.IGNORECASE),
    # Bracketed level: "[ERROR] something"
    re.compile(r'^\s*\[\s*(DEBUG|INFO|WARNING|ERROR|CRITICAL)\s*\]\b', re.IGNORECASE),
    # Key/value style: "level=error ..."
    re.compile(r'\blevel\s*=\s*(debug|info|warning|error|critical)\b', re.IGNORECASE),
]

TIME_LEVEL_PREFIX = re.compile(
    r'^\s*(?:\d{2}:\d{2}:\d{2}(?:[.,]\d+)?)\s+(DEBUG|INFO|WARNING|ERROR|CRITICAL)\s*[:-]?\s*',
    re.IGNORECASE,
)

def normalize_path(*args: Any, **kwargs: Any) -> Any: ...

def parse_level(*args: Any, **kwargs: Any) -> Any: ...

def strip_time_level_prefix(*args: Any, **kwargs: Any) -> Any: ...

def is_packaging_cmd(*args: Any, **kwargs: Any) -> Any: ...

class _AgiEnvMeta(type):
    def __getattribute__(cls, *args: Any, **kwargs: Any) -> Any: ...
    def __setattr__(cls, *args: Any, **kwargs: Any) -> Any: ...

class AgiEnv:
    def __new__(cls, *args: Any, **kwargs: Any) -> Any: ...
    def current(cls) -> Any: ...
    def reset(cls) -> Any: ...
    def __init__(self, *args: Any, **kwargs: Any) -> Any: ...
    def _resolve_package(*args: Any, **kwargs: Any) -> Any: ...
    def _get_private_apps_root(self) -> Any: ...
    def _collect_pythonpath_entries(self) -> Any: ...
    def _configure_pythonpath(self, *args: Any, **kwargs: Any) -> Any: ...
    def _dedupe_paths(*args: Any, **kwargs: Any) -> Any: ...
    def has_agilab_anywhere_under_home(self, *args: Any, **kwargs: Any) -> Any: ...
    def active(self, *args: Any, **kwargs: Any) -> Any: ...
    def humanize_validation_errors(self, *args: Any, **kwargs: Any) -> Any: ...
    def set_env_var(*args: Any, **kwargs: Any) -> Any: ...
    def _ensure_defaults(cls) -> Any: ...
    def read_agilab_path(*args: Any, **kwargs: Any) -> Any: ...
    def locate_agilab_installation(*args: Any, **kwargs: Any) -> Any: ...
    def copy_existing_projects(self, *args: Any, **kwargs: Any) -> Any: ...
    def _update_env_file(*args: Any, **kwargs: Any) -> Any: ...
    def _init_resources(self, *args: Any, **kwargs: Any) -> Any: ...
    def _init_projects(self) -> Any: ...
    def get_projects(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_base_worker_cls(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_base_classes(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_import_mapping(self, *args: Any, **kwargs: Any) -> Any: ...
    def _ensure_private_app_link(self) -> Any: ...
    def extract_base_info(self, *args: Any, **kwargs: Any) -> Any: ...
    def get_full_attribute_name(self, *args: Any, **kwargs: Any) -> Any: ...
    def mode2str(self, *args: Any, **kwargs: Any) -> Any: ...
    def mode2int(*args: Any, **kwargs: Any) -> Any: ...
    def is_valid_ip(self, *args: Any, **kwargs: Any) -> Any: ...
    def init_envars_app(self, *args: Any, **kwargs: Any) -> Any: ...
    def _copy_file(*args: Any, **kwargs: Any) -> Any: ...
    def _init_apps(self) -> Any: ...
    def _build_env(*args: Any, **kwargs: Any) -> Any: ...
    def log_info(*args: Any, **kwargs: Any) -> Any: ...
    def run(*args: Any, **kwargs: Any) -> Any: ...
    def _run_bg(*args: Any, **kwargs: Any) -> Any: ...
    def run_agi(self, *args: Any, **kwargs: Any) -> Any: ...
    def run_async(*args: Any, **kwargs: Any) -> Any: ...
    def create_symlink(*args: Any, **kwargs: Any) -> Any: ...
    def change_app(self, *args: Any, **kwargs: Any) -> Any: ...
    def is_local(*args: Any, **kwargs: Any) -> Any: ...
    def has_admin_rights(*args: Any, **kwargs: Any) -> Any: ...
    def create_junction_windows(*args: Any, **kwargs: Any) -> Any: ...
    def create_symlink_windows(*args: Any, **kwargs: Any) -> Any: ...
    def create_rename_map(self, *args: Any, **kwargs: Any) -> Any: ...
    def clone_project(self, *args: Any, **kwargs: Any) -> Any: ...
    def clone_directory(self, *args: Any, **kwargs: Any) -> Any: ...
    def _cleanup_rename(self, *args: Any, **kwargs: Any) -> Any: ...
    def replace_content(self, *args: Any, **kwargs: Any) -> Any: ...
    def read_gitignore(self, *args: Any, **kwargs: Any) -> Any: ...
    def is_valid_ip(self, *args: Any, **kwargs: Any) -> Any: ...
    def unzip_data(self, *args: Any, **kwargs: Any) -> Any: ...
    def check_internet(*args: Any, **kwargs: Any) -> Any: ...

class ContentRenamer(ast.NodeTransformer):
    def __init__(self, *args: Any, **kwargs: Any) -> Any: ...
    def visit_Name(self, *args: Any, **kwargs: Any) -> Any: ...
    def visit_Attribute(self, *args: Any, **kwargs: Any) -> Any: ...
    def visit_FunctionDef(self, *args: Any, **kwargs: Any) -> Any: ...
    def visit_ClassDef(self, *args: Any, **kwargs: Any) -> Any: ...
    def visit_arg(self, *args: Any, **kwargs: Any) -> Any: ...
    def visit_Global(self, *args: Any, **kwargs: Any) -> Any: ...
    def visit_nonlocal(self, *args: Any, **kwargs: Any) -> Any: ...
    def visit_Assign(self, *args: Any, **kwargs: Any) -> Any: ...
    def visit_AnnAssign(self, *args: Any, **kwargs: Any) -> Any: ...
    def visit_For(self, *args: Any, **kwargs: Any) -> Any: ...
    def visit_Import(self, *args: Any, **kwargs: Any) -> Any: ...
    def visit_ImportFrom(self, *args: Any, **kwargs: Any) -> Any: ...

def _is_relative_to(*args: Any, **kwargs: Any) -> Any: ...
